<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive SHM Simulation v2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #1e3a5f;
        }
        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
        }
        .simulation-panel, .controls-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .simulation-panel {
            flex: 2;
            min-width: 400px;
        }
        .controls-panel {
            flex: 1;
            min-width: 300px;
        }
        #simCanvas {
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
        }
        .graph-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            width: 100%;
            margin-top: 20px;
        }
        .graph-item {
             background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="range"] {
            width: 100%;
        }
        .button-group button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #2c5282;
            color: white;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.2s;
        }
        .button-group button:hover {
            background-color: #1e3a5f;
        }
        #aiTutorBox {
            margin-top: 20px;
            padding: 15px;
            background-color: #e2e8f0;
            border-radius: 5px;
            border-left: 5px solid #4a5568;
        }
        #aiTutorBox h4 { margin: 0 0 10px 0; }
        #aiTutorBox p { margin: 0; }
        .checkbox-group label {
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            margin-right: 15px;
        }
        .checkbox-group input {
            margin-right: 5px;
        }
    </style>
</head>
<body>

    <h1>Interactive AI Simulation: Simple Harmonic Motion</h1>

    <div class="main-container">
        <div class="simulation-panel">
            <h3>Simulation Sandbox</h3>
            <canvas id="simCanvas" width="600" height="200"></canvas>
        </div>
        <div class="controls-panel">
            <h3>Controls</h3>
            <div class="control-group">
                <label for="mass">Mass (m): <span id="massValue">1.0</span> kg</label>
                <input type="range" id="mass" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label for="springConst">Spring Constant (k): <span id="springConstValue">5</span> N/m</label>
                <input type="range" id="springConst" min="1" max="20" step="0.5" value="5">
            </div>
            <div class="control-group">
                <label for="displacement">Initial Displacement (xâ‚€): <span id="displacementValue">80</span> px</label>
                <input type="range" id="displacement" min="-100" max="100" step="1" value="80">
            </div>
             <div class="control-group">
                <label for="damping">Damping (b): <span id="dampingValue">0.1</span></label>
                <input type="range" id="damping" min="0" max="1" step="0.05" value="0.1">
            </div>
            <div class="control-group checkbox-group">
                <label><input type="checkbox" id="showGridCheck"> Show Grid</label>
                <label><input type="checkbox" id="showVectorsCheck" checked> Show Vectors</label>
            </div>
            <hr style="border: 1px solid #eee; margin: 20px 0;">
            <div class="button-group">
                <button id="playPauseBtn">Play</button>
                <button id="resetBtn">Reset</button>
            </div>
            <div id="aiTutorBox">
                <h4>ðŸ§  AI Tutor</h4>
                <p id="aiMessage">Welcome! I've added checkboxes to show a grid and force vectors.</p>
            </div>
        </div>
    </div>

    <div class="graph-container">
        <div class="graph-item">
            <canvas id="positionChart"></canvas>
        </div>
        <div class="graph-item">
            <canvas id="velocityChart"></canvas>
        </div>
        <div class="graph-item">
            <canvas id="energyChart"></canvas>
        </div>
    </div>

<script>
    // --- SETUP ---
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // Controls
    const massSlider = document.getElementById('mass');
    const springConstSlider = document.getElementById('springConst');
    const displacementSlider = document.getElementById('displacement');
    const dampingSlider = document.getElementById('damping');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    // NEW: Checkbox controls
    const showGridCheck = document.getElementById('showGridCheck');
    const showVectorsCheck = document.getElementById('showVectorsCheck');


    // Value displays
    const massValue = document.getElementById('massValue');
    const springConstValue = document.getElementById('springConstValue');
    const displacementValue = document.getElementById('displacementValue');
    const dampingValue = document.getElementById('dampingValue');
    
    // AI Tutor
    const aiMessage = document.getElementById('aiMessage');

    // Simulation state
    let state = {
        m: parseFloat(massSlider.value),
        k: parseFloat(springConstSlider.value),
        x0: parseFloat(displacementSlider.value),
        b: parseFloat(dampingSlider.value),
        v0: 0,
        t: 0,
        startTime: null,
        isRunning: false,
        animationFrameId: null,
        // NEW: Display state
        showGrid: showGridCheck.checked,
        showVectors: showVectorsCheck.checked
    };

    // Chart objects
    let posChart, velChart, energyChart;
    const chartTimeWindow = 15;

    // --- PHYSICS & SIMULATION LOGIC ---
    function updateDerivedProperties() {
        state.omega0 = Math.sqrt(state.k / state.m); // Natural angular frequency
        state.gamma = state.b / (2 * state.m); // Damping ratio
        state.omega = Math.sqrt(state.omega0**2 - state.gamma**2); // Damped angular frequency
        state.period = 2 * Math.PI / state.omega;
    }

    function getSystemState(t) {
        if (state.gamma >= state.omega0) { // Critical or Overdamped case
             return { x: 0, v: 0, ke: 0, pe: 0, te: 0 };
        }
        
        const amplitude = state.x0;
        const decay = Math.exp(-state.gamma * t);
        
        const x = amplitude * decay * Math.cos(state.omega * t);
        const v = -amplitude * decay * (state.gamma * Math.cos(state.omega * t) + state.omega * Math.sin(state.omega * t));
        
        const ke = 0.5 * state.m * v * v;
        const pe = 0.5 * state.k * x * x;
        const te = ke + pe;

        return { x, v, ke, pe, te };
    }

    // --- DRAWING & VISUALIZATION ---

    // NEW: Helper function to draw arrows
    function drawArrow(fromX, fromY, toX, toY, color) {
        const headlen = 10; // length of head in pixels
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    function drawSystem(systemState) {
        const { x } = systemState;
        const width = canvas.width;
        const height = canvas.height;
        const equilibrium = width / 2;
        const massSize = 30 + state.m * 5;
        const massCenterY = height / 2;
        const springPos = equilibrium + x;
        const massCenterX = springPos;

        ctx.clearRect(0, 0, width, height);

        // NEW: Draw Grid
        if (state.showGrid) {
            const gridSize = 20;
            ctx.beginPath();
            for (let i = 0; i < width; i += gridSize) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
            }
            for (let j = 0; j < height; j += gridSize) {
                ctx.moveTo(0, j);
                ctx.lineTo(width, j);
            }
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }

        // Draw spring
        ctx.beginPath();
        ctx.moveTo(0, massCenterY);
        const springSegments = 20;
        for (let i = 0; i < springSegments; i++) {
            const sx = (massCenterX - massSize/2) / springSegments * i;
            const sy = massCenterY + ((i % 2 === 0) ? 10 : -10);
            ctx.lineTo(sx, sy);
        }
        ctx.lineTo(massCenterX - massSize / 2, massCenterY);
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw mass
        ctx.fillStyle = '#2c5282';
        ctx.fillRect(massCenterX - massSize / 2, massCenterY - massSize / 2, massSize, massSize);

        // Draw equilibrium line
        ctx.beginPath();
        ctx.moveTo(equilibrium, 0);
        ctx.lineTo(equilibrium, height);
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#a0aec0';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);
        
        // NEW: Draw Vectors
        if (state.showVectors && x !== 0) {
            const vectorScale = 1.5; // To make vectors visible
            const force = -state.k * x;

            // Displacement vector (blue)
            drawArrow(massCenterX, massCenterY + massSize / 2 + 10, massCenterX + x, massCenterY + massSize / 2 + 10, '#3182ce');
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#3182ce';
            ctx.fillText('x (displacement)', massCenterX + x/2 - 40, massCenterY + massSize / 2 + 30);
            
            // Force vector (red)
            drawArrow(massCenterX, massCenterY - massSize / 2 - 10, massCenterX + force * vectorScale, massCenterY - massSize / 2 - 10, '#e53e3e');
            ctx.fillStyle = '#e53e3e';
            ctx.fillText('F (restoring force)', massCenterX + force*vectorScale/2 - 50, massCenterY - massSize / 2 - 25);
        }
    }

    function createCharts() {
        const commonOptions = { /* ... (same as before) ... */ };
        posChart = new Chart(/* ... */);
        velChart = new Chart(/* ... */);
        energyChart = new Chart(/* ... */);
    }
    // Hiding chart creation for brevity, it's unchanged from previous version
    function createCharts() {
        const commonOptions = {
            scales: {
                x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Time (s)' }, min: 0, max: chartTimeWindow },
                y: { title: { display: true } }
            },
            plugins: { legend: { display: true } },
            elements: { point: { radius: 0 } },
            animation: { duration: 0 }
        };

        posChart = new Chart(document.getElementById('positionChart'), {
            type: 'line', data: { datasets: [{ label: 'Position (px)', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] },
            options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { ...commonOptions.scales.y.title, text: 'Position (px)'}}}}
        });

        velChart = new Chart(document.getElementById('velocityChart'), {
            type: 'line', data: { datasets: [{ label: 'Velocity (px/s)', data: [], borderColor: 'rgb(255, 99, 132)', tension: 0.1 }] },
            options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { ...commonOptions.scales.y.title, text: 'Velocity (px/s)'}}}}
        });

        energyChart = new Chart(document.getElementById('energyChart'), {
            type: 'line', data: { datasets: [
                    { label: 'Kinetic Energy', data: [], borderColor: 'rgb(54, 162, 235)', tension: 0.1 },
                    { label: 'Potential Energy', data: [], borderColor: 'rgb(255, 206, 86)', tension: 0.1 },
                    { label: 'Total Energy', data: [], borderColor: 'rgb(153, 102, 255)', tension: 0.1 }
                ]},
            options: { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { ...commonOptions.scales.y.title, text: 'Energy (Joules)'}}}}
        });
    }

    function updateCharts(t, systemState) {
        /* ... (same as before) ... */
        const charts = [posChart, velChart, energyChart];
        const { x, v, ke, pe, te } = systemState;
        
        posChart.data.datasets[0].data.push({x: t, y: x});
        velChart.data.datasets[0].data.push({x: t, y: v});
        energyChart.data.datasets[0].data.push({x: t, y: ke / 100}); // Scaled
        energyChart.data.datasets[1].data.push({x: t, y: pe / 100});
        energyChart.data.datasets[2].data.push({x: t, y: te / 100});

        charts.forEach(chart => {
            if (t > chartTimeWindow) {
                chart.options.scales.x.min = t - chartTimeWindow;
                chart.options.scales.x.max = t;
            }
            chart.update();
        });
    }

    function clearCharts() { /* ... (same as before) ... */
        [posChart, velChart, energyChart].forEach(chart => {
            chart.data.datasets.forEach(dataset => { dataset.data = []; });
            chart.options.scales.x.min = 0;
            chart.options.scales.x.max = chartTimeWindow;
            chart.update();
        });
    }

    // --- MAIN LOOP ---
    function animate(timestamp) {
        if (!state.isRunning) return;
        if (!state.startTime) state.startTime = timestamp;
        const elapsedTime = (timestamp - state.startTime) / 1000;
        state.t = elapsedTime;

        const systemState = getSystemState(state.t);
        drawSystem(systemState); // Pass the whole state object now
        updateCharts(state.t, systemState);

        state.animationFrameId = requestAnimationFrame(animate);
    }
    
    // --- EVENT HANDLERS & AI ---
    function handlePlayPause() { /* ... */ }
    function handlePlayPause() {
        state.isRunning = !state.isRunning;
        playPauseBtn.textContent = state.isRunning ? 'Pause' : 'Play';
        if (state.isRunning) {
            state.startTime = performance.now() - state.t * 1000;
            state.animationFrameId = requestAnimationFrame(animate);
            setAiMessage("Simulation running. Notice how the red force vector always points towards the center equilibrium line.", "info");
        } else {
            cancelAnimationFrame(state.animationFrameId);
            setAiMessage("Simulation paused. Toggle the checkboxes to see how the display changes!", "info");
        }
    }

    function handleReset() {
        state.isRunning = false;
        playPauseBtn.textContent = 'Play';
        cancelAnimationFrame(state.animationFrameId);

        state.t = 0;
        state.startTime = null;
        state.x0 = parseFloat(displacementSlider.value);
        
        updateDerivedProperties();
        const initialSystemState = getSystemState(0);
        drawSystem(initialSystemState);
        
        clearCharts();
        setAiMessage("System reset. Press 'Play' to start again.", "info");
    }

    function setAiMessage(message) {
        aiMessage.textContent = message;
    }
    
    massSlider.addEventListener('input', (e) => {
        state.m = parseFloat(e.target.value);
        massValue.textContent = state.m.toFixed(1);
        handleReset();
        setAiMessage(`Mass (inertia) is now ${state.m} kg. A larger mass resists changes in motion, so the period of oscillation will be longer.`);
    });

    springConstSlider.addEventListener('input', (e) => {
        state.k = parseFloat(e.target.value);
        springConstValue.textContent = state.k.toFixed(1);
        handleReset();
        setAiMessage(`Spring constant (stiffness) is ${state.k} N/m. A stiffer spring creates a larger restoring force for the same displacement.`);
    });
    
    displacementSlider.addEventListener('input', (e) => {
        state.x0 = parseFloat(e.target.value);
        displacementValue.textContent = state.x0.toFixed(0);
        handleReset();
        setAiMessage(`Initial displacement is now ${state.x0} px. This sets the initial potential energy and the amplitude of the motion.`);
    });

    dampingSlider.addEventListener('input', (e) => {
        state.b = parseFloat(e.target.value);
        dampingValue.textContent = state.b.toFixed(2);
        handleReset();
        setAiMessage(`Damping is set to ${state.b}. This represents friction, causing the system to lose energy over time.`);
    });

    // NEW: Event listeners for checkboxes
    showGridCheck.addEventListener('change', (e) => {
        state.showGrid = e.target.checked;
        // Redraw immediately without resetting the physics
        drawSystem(getSystemState(state.t));
    });
    
    showVectorsCheck.addEventListener('change', (e) => {
        state.showVectors = e.target.checked;
        drawSystem(getSystemState(state.t));
        if (e.target.checked) {
             setAiMessage("Vectors are on! The red force vector always opposes the blue displacement vector, which is the essence of SHM.");
        }
    });

    playPauseBtn.addEventListener('click', handlePlayPause);
    resetBtn.addEventListener('click', handleReset);

    // --- INITIALIZATION ---
    window.onload = () => {
        createCharts();
        handleReset();
    };

</script>
</body>
</html>